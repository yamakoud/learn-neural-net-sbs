
このコードではフィードフォワード（順伝播）のみの多層パーセプトロンを実装しています。

フィードフォワードを行うためには、各層の重みとバイアスを用意し、入力に対して重みを掛けてバイアスを足し合わせることで出力を計算します。
活性化関数は通常、シグモイド関数が使われますが、これは後の課題で扱います。


## コード解説

### 0. 行列の積の計算

まず、行列の計算から解説します。

行列というのは、数値を縦横に並べたものです。
プログラミングでは二次元配列と同じようなものと考えてもらって構いません。
ruby で表現すると以下のようになります。

```ruby
require 'matrix'

a = Matrix[
  [1, 2, 3],
  [4, 5, 6]
]

```

また、これら行列を掛け合わせるときは普通に `*` 演算子を使います。

ただし注意しておかないといけないのは、行列の積は「左の行列の列数」と「右の行列の行数」が一致している必要があるということです。
例えば、上記の `a` と `b` の積を計算するときは、`a` の列数が `3` で `b` の行数が `3` なので計算できます。
言い換えると `a` は `2x3` の行列で、`b` は `3x2` の行列です。
なので `a * b` の演算が可能です。

```ruby
a = Matrix[
  [1, 2, 3],
  [4, 5, 6]
]
b = Matrix[
  [5, 6],
  [7, 8],
  [9, 10]
]
# 2x3行列と3x2行列の積 -> 2x2の行列になる
# c = [
#   [1*5 + 2*7 + 3*9, 1*6 + 2*8 + 3*10],
#   [4*5 + 5*7 + 6*9, 4*6 + 5*8 + 6*10]
# ]
c = a * b
```

TODO: ここにできない場合の説明とエラー例を追加する


### 1. ForwardOnlyMLPクラスの定義

```ruby


class ForwardOnlyMLP
  def initialize(input_size, hidden_size, output_size)
    @w1 = Matrix.build(input_size, hidden_size) { rand(-1.0..1.0) }
    @w2 = Matrix.build(hidden_size, output_size) { rand(-1.0..1.0) }
  end

  def forward(x)
    x = Matrix[x]
    z1 = x * @w1
    a1 = z1.map { |e| sigmoid(e) }
    z2 = a1 * @w2
    a2 = z2.map { |e| sigmoid(e) }
    a2.to_a.flatten
  end
end
```

- `initialize`メソッドでは、入力層のサイズ、隠れ層のサイズ、出力層のサイズを受け取り、重み行列を初期化します。
- `forward`メソッドでは、入力`x`を受け取り、順伝播を行って出力を計算します。（行列の積の計算）
