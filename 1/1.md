
このコードではフィードフォワード（順伝播）のみの多層パーセプトロンを実装しています。

フィードフォワードを行うためには、各層の重みとバイアスを用意し、入力に対して重みを掛けてバイアスを足し合わせることで出力を計算します。
活性化関数は通常、シグモイド関数が使われますが、これは後の課題で扱います。


## コード解説

### 0. 行列の積の計算

まず、行列の計算から解説します。

行列というのは、数値を縦横に並べたものです。

プログラミングでは二次元配列と同じようなものと考えてもらって構いません。

ruby で表現すると以下のようになります。

```ruby
require 'matrix'

a = Matrix[
  [1, 2, 3],
  [4, 5, 6]
]
```

また、これら行列を掛け合わせるときは普通に `*` 演算子を使います。

ただし注意しておかないといけないのは、行列の積は「左の行列の列数」と「右の行列の行数」が一致している必要があるということです。

#### 行列の積の計算例

ここで `2*3` 行列 `a` と `3*2` 行列 `b` の積を考えてみましょう。

```ruby
require 'matrix'

a = Matrix[
  [1, 2, 3],
  [4, 5, 6]
]
b = Matrix[
  [5, 6],
  [7, 8],
  [9, 10]
]

# 2x3行列と3x2行列の積 -> 2x2の行列になる
# i*j行列とj*k行列の積はi*k行列になるという性質があるので c は 2x2 の行列になる
# c = [
#   [1*5 + 2*7 + 3*9, 1*6 + 2*8 + 3*10],
#   [4*5 + 5*7 + 6*9, 4*6 + 5*8 + 6*10]
# ]
c = a * b
```

上記の `a` と `b` の積を計算するときは、`a` の列数が `3` で `b` の行数が `3` になるので計算可能になります。

逆に、`a` の列数と `b` の行数が一致していない場合は計算できません。

これは行列の積の演算は前の行列の列数と後の行列の行数が一致していないと計算できなことが数学的に定義されているためです。

むずかしいかもしれませんが、簡単にいうとゼロ除算と同じようなものです。

（ゼロ除算って数学的に定義されていないので、プログラムでエラーになるのは当然ですよね。）

#### 行列の積の計算例（エラー）

次は実際に次元が合ってない場合に行列の積が計算できないことを確認してみましょう。

走らせてみるのは下記のコマンドです

```ruby
require 'matrix'
a = Matrix[[1,2,3],[4,5,6]]
b = a.clone
a * b
```

irb とかで試してみてください。

（matrix は標準ライブラリなので、インストールは不要です）

```sh
irb(main):006> a = Matrix[[1,2,3],[4,5,6]]
=> Matrix[[1, 2, 3], [4, 5, 6]]
irb(main):007> b = a.clone
=> Matrix[[1, 2, 3], [4, 5, 6]]
irb(main):008> a * b
/home/yamakoud/.local/share/mise/installs/ruby/3.3.4/lib/ruby/gems/3.3.0/gems/matrix-0.4.2/lib/matrix.rb:1070:in `*': Dimension mismatch (ExceptionForMatrix::ErrDimensionMismatch)
        from (irb):8:in `<main>'
        from <internal:kernel>:187:in `loop'
        from /home/yamakoud/.local/share/mise/installs/ruby/3.3.4/lib/ruby/gems/3.3.0/gems/irb-1.13.1/exe/irb:9:in `<top (required)>'
        from /home/yamakoud/.local/share/mise/installs/ruby/latest/bin/irb:25:in `load'
        from /home/yamakoud/.local/share/mise/installs/ruby/latest/bin/irb:25:in `<main>'
```

`2*3` 行列と `2*3` 行列の積は計算できない（数学的に定義されていない）ので、エラーが発生しているのが確認できました。

### 1. ForwardOnlyMLPクラスの定義

```ruby


class ForwardOnlyMLP
  def initialize(input_size, hidden_size, output_size)
    @w1 = Matrix.build(input_size, hidden_size) { rand(-1.0..1.0) }
    @w2 = Matrix.build(hidden_size, output_size) { rand(-1.0..1.0) }
  end

  def forward(x)
    x = Matrix[x]
    z1 = x * @w1
    a1 = z1.map { |e| sigmoid(e) }
    z2 = a1 * @w2
    a2 = z2.map { |e| sigmoid(e) }
    a2.to_a.flatten
  end
end
```

- `initialize`メソッドでは、入力層のサイズ、隠れ層のサイズ、出力層のサイズを受け取り、重み行列を初期化します。
- `forward`メソッドでは、入力`x`を受け取り、順伝播を行って出力を計算します。（行列の積の計算）
